<div dir="rtl">

# سوال اول
### 1. تفاوت reference-type بودن `map` و `slice` در Go چه تأثیری در طراحی API دارد؟
(چه زمانی map را return کنیم و چه زمانی نباید؟)

#### پاسخ خلاصه:
در Go، هم `map` و هم `slice` از نوع reference-type هستند. یعنی هنگام return یا ارسال به توابع، فقط آدرس آن‌ها منتقل می‌شود، نه یک کپی از داده. این موضوع می‌تواند باعث بروز تغییرات ناخواسته در داده‌ها (side-effect) شود، مخصوصاً اگر caller یا callee داده را تغییر دهد.

#### تحلیل:
1. `map` ها همیشه mutable هستند حتی زمانی که به ظاهر فقط خوانده می‌شوند.

<div dir="ltr">

```go
func GetSettings() map[string]string {
    return map[string]string{"env": "prod"}
}

s := GetSettings()
s["env"] = "dev"
```
</div>

2. استفاده از `map` به عنوان shared state میان goroutineها می‌تواند منجر به data race شود، مگر اینکه از مکانیزم‌های sync (مثل `sync.Mutex`) استفاده شود.

3. با این حال، return کردن map در برخی موقعیت‌ها مفید است:
- زمانی که نیاز به قابلیت اصلاح یا گسترش map در سمت caller دارید
- زمانی که performance مهم است و نمی‌خواهید کپی‌های غیرضروری گرفته شود

#### پیشنهاد طراحی:

| سناریو              | پیشنهاد                                                                 |
|----------------------|--------------------------------------------------------------------------|
| نیاز فقط به خواندن   | کپی از map تهیه کرده و return کنید                                     |
| نیاز به کنترل بیشتر | از struct با methodهای کنترل‌شده برای مدیریت دسترسی به map استفاده کنید |
| حساس به performance | map را مستقیم return کنید ولی در مستندات عواقب احتمالی را توضیح دهید   |


# سوال دوم
### 2. چرا در Go مقداردهی اولیه‌ی متغیرها (zero value) باعث حذف constructor ها می شود و چه خطراتی دارد؟

#### پاسخ خلاصه:
در Go، هر متغیر از هر نوعی که باشد، حتی بدون مقداردهی صریح نیز دارای مقدار اولیه معتبر (zero value) است. این تصمیم زبانی باعث شده که برنامه‌نویس‌ها اغلب نیازی به تعریف constructor نداشته باشند. اما این سادگی ظاهری ممکن است منجر به ایجاد object هایی شود که ناقص یا به‌درستی مقداردهی نشده‌اند، در حالی که از بیرون "معتبر" به‌نظر می‌رسند.

#### تحلیل:

1. فلسفه طراحی Go بر سادگی و مینیمالیسم تأکید دارد. مقداردهی خودکار با `zero value` باعث می‌شود بتوان structs را بدون نیاز به constructor ایجاد و استفاده کرد.

<div dir="ltr">

```go
type Config struct {
    Port   int
    Secure bool
}

var cfg Config // cfg.Port == 0, cfg.Secure == false
```

</div>

برخلاف زبان‌هایی مانند Java یا C++ که عدم مقداردهی می‌تواند به رفتار undefined منجر شود، در Go مقداردهی اولیه همیشه تضمین‌شده است.

اما همین سادگی می‌تواند خطرناک باشد. اگر struct ای نیاز به مقداری خاص برای عملکرد درست دارد (مثلاً dependency injection یا مقدارهای بحرانی)، عدم استفاده از constructor ممکن است باعث شود struct در وضعیت ناپایدار استفاده شود.

<div dir="ltr">

```go
type Logger struct {
    Writer io.Writer
}

func (l *Logger) Log(msg string) {
    if l.Writer != nil {
        l.Writer.Write([]byte(msg))
    }
}

var l Logger
l.Log("oops!") // هیچ اتفاقی نمی‌افتد چون Writer مقداردهی نشده

```

</div>

این رفتار مخصوصاً زمانی مشکل‌ساز می‌شود که struct پیچیده‌تر است یا به منابع خارجی متکی است (فایل، کانکشن، کانال، ...)

پیشنهاد طراحی:
نیاز	راهکار پیشنهادی
struct ساده با مقدارهای پیش‌فرض	zero value کافی است
struct با مقادیر بحرانی یا dependency ها	استفاده از factory function (مثل ()NewT) یا initializer
struct با اعتبارسنجی پیچیده	از unexported fields + constructor برای کنترل ساخت استفاده کنید

</div>