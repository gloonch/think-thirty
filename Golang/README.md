<div dir="rtl">

# سوال اول
### 1. تفاوت reference-type بودن `map` و `slice` در Go چه تأثیری در طراحی API دارد؟
(چه زمانی map را return کنیم و چه زمانی نباید؟)

#### پاسخ خلاصه:
در Go، هم `map` و هم `slice` از نوع reference-type هستند. یعنی هنگام return یا ارسال به توابع، فقط آدرس آن‌ها منتقل می‌شود، نه یک کپی از داده. این موضوع می‌تواند باعث بروز تغییرات ناخواسته در داده‌ها (side-effect) شود، مخصوصاً اگر caller یا callee داده را تغییر دهد.

#### تحلیل:
1. `map` ها همیشه mutable هستند حتی زمانی که به ظاهر فقط خوانده می‌شوند.

<div dir="ltr">

```go
func GetSettings() map[string]string {
    return map[string]string{"env": "prod"}
}

s := GetSettings()
s["env"] = "dev"
```
</div>

2. استفاده از `map` به عنوان shared state میان goroutineها می‌تواند منجر به data race شود، مگر اینکه از مکانیزم‌های sync (مثل `sync.Mutex`) استفاده شود.

3. با این حال، return کردن map در برخی موقعیت‌ها مفید است:
- زمانی که نیاز به قابلیت اصلاح یا گسترش map در سمت caller دارید
- زمانی که performance مهم است و نمی‌خواهید کپی‌های غیرضروری گرفته شود

#### پیشنهاد طراحی:

| سناریو              | پیشنهاد                                                                 |
|----------------------|--------------------------------------------------------------------------|
| نیاز فقط به خواندن   | کپی از map تهیه کرده و return کنید                                     |
| نیاز به کنترل بیشتر | از struct با methodهای کنترل‌شده برای مدیریت دسترسی به map استفاده کنید |
| حساس به performance | map را مستقیم return کنید ولی در مستندات عواقب احتمالی را توضیح دهید   |


# سوال دوم
### 2. چرا در Go مقداردهی اولیه‌ی متغیرها (zero value) باعث حذف constructor ها می شود و چه خطراتی دارد؟

#### پاسخ خلاصه:
در Go، هر متغیر از هر نوعی که باشد، حتی بدون مقداردهی صریح نیز دارای مقدار اولیه معتبر (zero value) است. این تصمیم زبانی باعث شده که برنامه‌نویس‌ها اغلب نیازی به تعریف constructor نداشته باشند. اما این سادگی ظاهری ممکن است منجر به ایجاد object هایی شود که ناقص یا به‌درستی مقداردهی نشده‌اند، در حالی که از بیرون "معتبر" به‌نظر می‌رسند.

#### تحلیل:

1. فلسفه طراحی Go بر سادگی و مینیمالیسم تأکید دارد. مقداردهی خودکار با `zero value` باعث می‌شود بتوان structs را بدون نیاز به constructor ایجاد و استفاده کرد.

<div dir="ltr">

```go
type Config struct {
    Port   int
    Secure bool
}

var cfg Config // cfg.Port == 0, cfg.Secure == false
```

</div>

برخلاف زبان‌هایی مانند Java یا C++ که عدم مقداردهی می‌تواند به رفتار undefined منجر شود، در Go مقداردهی اولیه همیشه تضمین‌شده است.

اما همین سادگی می‌تواند خطرناک باشد. اگر struct ای نیاز به مقداری خاص برای عملکرد درست دارد (مثلاً dependency injection یا مقدارهای بحرانی)، عدم استفاده از constructor ممکن است باعث شود struct در وضعیت ناپایدار استفاده شود.

<div dir="ltr">

```go
type Logger struct {
    Writer io.Writer
}

func (l *Logger) Log(msg string) {
    if l.Writer != nil {
        l.Writer.Write([]byte(msg))
    }
}

var l Logger
l.Log("oops!") // هیچ اتفاقی نمی‌افتد چون Writer مقداردهی نشده

```

</div>

این رفتار مخصوصاً زمانی مشکل‌ساز می‌شود که struct پیچیده‌تر است یا به منابع خارجی متکی است (فایل، کانکشن، کانال، ...)

پیشنهاد طراحی:
نیاز	راهکار پیشنهادی
struct ساده با مقدارهای پیش‌فرض	zero value کافی است
struct با مقادیر بحرانی یا dependency ها	استفاده از factory function (مثل ()NewT) یا initializer
struct با اعتبارسنجی پیچیده	از unexported fields + constructor برای کنترل ساخت استفاده کنید


# سوال سوم
### 3. چه زمانی استفاده از interface{} در طراحی API قابل قبول است، و چه زمانی smell حساب می‌شود؟
   پاسخ خلاصه:
   استفاده از interface{} در Go زمانی قابل‌قبول است که واقعاً نمی‌دانیم یا نمی‌خواهیم بدانیم نوع دقیق داده چیست — مانند serialization، logging یا generic containers. اما اگر interface{} در طراحی API به‌گونه‌ای به کار رود که وظایف تابع یا struct را مبهم کند یا نیاز به type assertion در سمت caller ایجاد کند، معمولاً به عنوان code smell شناخته می‌شود.

#### تحلیل:
- interface{} نماینده‌ی هر نوعی است — یعنی می‌تواند هر چیزی را نگه دارد. اما استفاده از آن هزینه‌هایی دارد:
- خوانایی و type safety را کاهش می‌دهد
- ممکن است نیاز به type assertion در سمت مصرف‌کننده ایجاد کند
- معماری را مبهم و غیرقابل تست کند
- موارد قابل‌قبول برای استفاده از interface{}:
- توابعی مانند fmt.Println یا loggers که باید با هر نوعی کار کنند
- استفاده در serialization/deserialization یا marshal/unmarshal
- مقادیر داخل map[string]interface{} که ساختارشان در زمان کامپایل مشخص نیست (مثلاً داده‌های JSON)
- مواردی که استفاده از interface{} smell محسوب می‌شود:
- زمانی که می‌دانیم دقیقاً چه نوع داده‌ای انتظار داریم ولی به‌جای آن از interface{} استفاده کرده‌ایم
- وقتی که API طراحی‌شده با interface{} نیاز دارد مصرف‌کننده با type switch یا reflect کار کند
- وقتی می‌توانستیم به‌جای interface{} از یک interface واضح‌تر و معنی‌دار (مثلاً io.Reader) استفاده کنیم ولی نکرده‌ایم

#### مثال مثبت:

<div dir="ltr">

```go
type Config struct {
	Port   int
	Secure bool
}
   
var cfg Config // cfg.Port == 0, cfg.Secure == false

```
</div>

#### مثال منفی:

<div dir="ltr">

```go
func Process(input interface{}) {
// type switch for different behaviours
   switch v := input.(type) {
   case string:
	   doSomethingWithString(v)
   case int:
	   doSomethingWithInt(v)
   default:
	   panic("unsupported type")
   }
}

```
</div>

 اینجا بهتر بود API تفکیک‌شده‌ای طراحی شود یا از interface هایی با رفتار مشخص استفاده شود.

#### پیشنهاد طراحی:

| وضعیت                            | رویکرد بهتر                                                           |
| -------------------------------- | --------------------------------------------------------------------- |
| داده ناشناخته (مثلاً JSON ورودی) | `map[string]interface{}` قابل قبول است                                |
| عملیات عمومی (مثل logger)        | استفاده از `interface{}` پذیرفته شده است                              |
| داده با نوع مشخص                 | تعریف interface معنیدار یا استفاده از struct خاص                      |
| نیاز به عملکرد polymorphic       | تعریف رفتار با interfaceهای محدود مثل `io.Reader` یا custom interface |



# سوال چهارم
### 4. در چه موقعیتی `()init` مفید واقع می‌شود و چه زمانی باعث پیچیدگی و پیش‌بینی‌ناپذیری می‌شود؟

#### پاسخ خلاصه:
تابع `()init` در Go برای مقداردهی اولیه package-level state یا تنظیمات وابسته به محیط استفاده می‌شود. اما استفاده‌ی بی‌رویه یا نامشخص از `()init` ممکن است باعث شود رفتار برنامه به‌صورت ضمنی تغییر کند و کد قابل‌پیش‌بینی و تست نباشد. به همین دلیل در بسیاری از پروژه‌ها استفاده‌ی بیش از حد از ()init به نحوی `discouraged` محسوب می‌شود.

#### تحلیل:

- `()init` به‌صورت خودکار و بدون فراخوانی مستقیم اجرا می‌شود؛ به همین دلیل معمولاً خارج از کنترل توسعه‌دهنده است.
- زمان اجرای آن پیش از `()main` و به ازای هر فایل یا پکیج فقط یک بار است.
- به دلیل اینکه فراخوانی آن explicit نیست، می‌تواند منبعی از رفتارهای مبهم، غیرقابل تست و مشکل‌ساز در هنگام testing یا reuse شود.
- وجود چند `()init` در پکیج‌های مختلف می‌تواند ترتیب اجرای غیرمنتظره ایجاد کند، مخصوصاً در برنامه‌های بزرگ.

#### مواردی که `()init` مفید است:
- ثبت شدن در یک registry در زمان import پکیج (مثلاً register شدن یک driver در `database/sql`)
- تنظیمات اولیه‌ای که باید پیش از استفاده انجام شوند ولی نیازی به پیکربندی خارجی ندارند
- مقداردهی default برای constants یا ساختارهای global (با وضوح بالا)

#### مواردی که `()init` مضر است:
- بارگذاری فایل‌ها یا environment-sensitive کارها که ممکن است در تست یا اجرای چندباره رفتار متفاوتی داشته باشند
- مقداردهی‌های مخفی که باعث شود کدهای دیگر بدون اطلاع، وابسته به این مقداردهی شوند
- هر گونه عملیات side-effect که بدون مستندات کافی انجام شود

#### مثال مثبت:

<div dir="ltr">

```go
var drivers = map[string]Driver{}

func Register(name string, d Driver) {
    drivers[name] = d
}

func init() {
    Register("postgres", newPostgresDriver())
}
```
</div>

 اینجا ()init به‌طور شفاف یک driver را به یک registry اضافه می‌کند، و برای مصرف‌کننده قابل پیش‌بینی است.

#### مثال منفی:
<div dir="ltr">

```go
func init() {
    file, _ := os.Open("config.json")
    config = parse(file)
}
```
</div>

 این نوع ()init می‌تواند باعث failure های پنهان در اجرای تست، یا وابستگی‌های خارج از کنترل در محیط‌های مختلف شود.

#### پیشنهاد طراحی:
| سناریو                              | رویکرد پیشنهادی                                                          |
| ----------------------------------- |--------------------------------------------------------------------------|
| مقداردهی اولیه ساده یا safe         | استفاده از `()init` در حد کم و قابل مستندسازی                            |
| نیاز به پیکربندی محیط یا فایل خارجی | پرهیز از `()init` و استفاده از تابع سازنده‌ی صریح (مانند `()LoadConfig`) |
| نیاز به ثبت شدن در پکیج دیگر        | مجاز است، ولی بهتر است در مستندات یا README اشاره شود                    |



</div>